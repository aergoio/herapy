# -*- coding: utf-8 -*-

import sys
import traceback

MAPSTRUCTURE = "mapstructure:"


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def find_conf_types(f, conf_type):
    line = f.readline()
    while line:
        line = line.strip()

        if "}" in line:
            return

        if line.startswith("//"):
            line = f.readline()
            continue

        sp = line.split()
        if 2 == len(sp):
            name, _ = line.split(None, 1)
        else:
            _, name, _ = line.split(None, 2)
            name = name.strip('*')

        pos = line.find(MAPSTRUCTURE) + len(MAPSTRUCTURE) + 1
        line2 = line[pos:]
        pos = line2.find('"')
        key = line2[:pos]
        if 'BaseConfig' == name:
            key = "base"

        conf_type[name] = {
            "key": key,
        }

        line = f.readline()


def find_conf_child_types(f, conf_type):
    line = f.readline()
    while line:
        line = line.strip()

        if "}" in line:
            return

        if line.startswith("//"):
            line = f.readline()
            continue

        pos = line.find(MAPSTRUCTURE) + len(MAPSTRUCTURE) + 1
        line2 = line[pos:]
        pos = line2.find('"')
        name = line2[:pos]

        _, var_type, _ = line.split(None, 2)

        conf_type[name] = var_type

        line = f.readline()


def main():
    if len(sys.argv) != 2:
        eprint("ERROR: input 'types.go' file path.")
        return

    go_src_path = sys.argv[1]
    eprint("Parsing Go Source file:", go_src_path)

    try:
        f = open(go_src_path)
        line = f.readline()

        conf_type = {}

        # parsing source file
        while line:
            line = line.strip()

            # check 'type'
            if 'type Config' in line:
                find_conf_types(f, conf_type)
            elif line.startswith('type '):
                _, child_conf, _ = line.split(None, 2)
                find_conf_child_types(f, conf_type[child_conf])

            line = f.readline()

        # generate python source code
        aergo_config_src = """
########################################
# !!!DO NOT MODIFY THIS FILE DIRECTLY!!!
########################################
#
# This file is generated by 'generate_aergo_conf.py'.
#
AERGO_DEFAULT_CONF = {
"""
        for k, v in conf_type.items():
            aergo_config_src += "    \"" + v['key'] + "\": {\n"

            for k2, v2 in v.items():
                if 'key' == k2:
                    continue

                aergo_config_src += "        \"" + k2 + "\": "

                if "string" == v2:
                    aergo_config_src += "\"\""
                elif "bool" == v2:
                    aergo_config_src += "False"
                elif "int" in v2:
                    aergo_config_src += "0"
                elif "[]string" == v2:
                    aergo_config_src += "[]"
                aergo_config_src += ",\n"

            aergo_config_src += "    },\n"
        aergo_config_src += "}\n\n"
        aergo_config_src += """
class AergoConfig:
    def __init__(self):
        self.__conf = AERGO_DEFAULT_CONF

"""
        for k, v in conf_type.items():
            key = v['key']
            aergo_config_src += "    @property\n"
            aergo_config_src += "    def " + key + "(self):\n"
            aergo_config_src += "        return self.__conf['" + key + "']\n\n"

            for k2, v2 in v.items():
                if 'key' == k2:
                    continue

                func_name = key + "_" + k2

                # generate property method
                aergo_config_src += "    @property\n"
                aergo_config_src += "    def " + func_name + "(self):\n"
                aergo_config_src += "        return self.__conf['" + key + "']['" + k2 + "']\n\n"

                # generate setter method
                aergo_config_src += "    @" + func_name + ".setter\n"
                aergo_config_src += "    def " + func_name + "(self, v):\n"
                aergo_config_src += "        if isinstance(v, "
                err_txt = key + "." + k2 + " should be"
                if "string" == v2:
                    aergo_config_src += "str"
                    err_txt += "a string type"
                elif "bool" == v2:
                    aergo_config_src += "bool"
                    err_txt += "a boolean type"
                elif "int" in v2:
                    aergo_config_src += "int"
                    err_txt += "a number type"
                elif "[]string" == v2:
                    aergo_config_src += "list"
                    err_txt += "an array type"
                aergo_config_src += "):\n"
                aergo_config_src += "            raise TypeError(\"" + err_txt + "\")\n"
                aergo_config_src += "        self.__conf['" + key + "']['" + k2 + "'] = v\n\n"

        print(aergo_config_src)
    except Exception as e:
        traceback.print_exception(*sys.exc_info())
    finally:
        f.close()


if __name__ == '__main__':
    main()
