# -*- coding: utf-8 -*-

import sys
import traceback
import toml

MAPSTRUCTURE = "mapstructure:"

DEBUG = False


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def find_conf_types(types_f, conf_type):
    line = types_f.readline()
    while line:
        line = line.strip()

        if "}" in line:
            return

        if line.startswith("//"):
            line = types_f.readline()
            continue

        sp = line.split()
        if 2 == len(sp):
            name, _ = line.split(None, 1)
        else:
            _, name, _ = line.split(None, 2)
            name = name.strip('*')

        pos = line.find(MAPSTRUCTURE) + len(MAPSTRUCTURE) + 1
        line2 = line[pos:]
        pos = line2.find('"')
        key = line2[:pos]

        conf_type[name] = {
            "key": key,
        }

        line = types_f.readline()


def find_conf_child_types(types_f, conf_type):
    line = types_f.readline()
    try:
        while line:
            line = line.strip()
            if line is None or 0 == len(line):
                line = types_f.readline()
                continue

            if "}" in line:
                return

            if line.startswith("//"):
                line = types_f.readline()
                continue

            pos = line.find(MAPSTRUCTURE) + len(MAPSTRUCTURE) + 1
            line2 = line[pos:]
            pos = line2.find('"')
            name = line2[:pos]

            _, var_type, _ = line.split(None, 2)

            conf_type[name] = var_type

            line = types_f.readline()
    except:
        eprint("ERROR: to parse line: ", line)
        raise


def main():
    if len(sys.argv) < 3:
        eprint("!!!MISSING ARGUMENTS: " + sys.argv[0] + " <'types.go' file path> <'aergo_default_conf.toml' file path>")
        return

    try:
        go_src_path = sys.argv[1]
        eprint("Parsing Go Source file:", go_src_path)

        types_f = open(go_src_path)
        line = types_f.readline()

        conf_type = {}

        # parsing source file
        while line:
            line = line.strip()

            # check 'type'
            if 'type Config' in line:
                find_conf_types(types_f, conf_type)
            elif line.startswith('type '):
                _, child_conf, _ = line.split(None, 2)
                find_conf_child_types(types_f, conf_type[child_conf])

            line = types_f.readline()
    except Exception as e:
        eprint("ERROR: to parse line: ", line)
        traceback.print_exception(*sys.exc_info())
    finally:
        types_f.close()

    # check default values of all configurations are set
    with open(sys.argv[2]) as toml_f:
        default_conf = toml.loads(toml_f.read())
    toml_f.close()

    no_default_keys = []
    for k, v in conf_type.items():
        category_name = v['key']
        for k2, v2 in v.items():
            if 'key' == k2:
                continue

            try:
                if "BaseConfig" == k:
                    default_value = default_conf[k2]
                else:
                    default_value = default_conf[category_name][k2]

                if v2 == "string":
                    default_value = '"' + default_value + '"'

                if DEBUG:
                    if k == "BaseConfig":
                        eprint("Default value of '{0}' = {1}".format(k2, default_value))
                    else:
                        eprint("Default value of '[{0}] {1}' = {2}".format(category_name, k2, default_value))
            except KeyError:
                eprint("!!!MISSING DEFAULT VALUE OF KEY: [{0}] {1}".format(k, k2))
                no_default_keys.append({
                    "category": k,
                    "key": k2
                })

    try:
        # generate python source code
        aergo_config_src = """
########################################
# !!!DO NOT MODIFY THIS FILE DIRECTLY!!!
########################################
#
# This file is generated by 'generate_aergo_conf.py'.
#
AERGO_CONF_KEYS = {
"""
        for k, v in conf_type.items():
            ws = " " * 4
            if "BaseConfig" == k:
                category_name = "base"
            else:
                category_name = v['key']

            aergo_config_src += "    \"" + category_name + "\": ["
            for k2, _ in v.items():
                if k2 == "key":
                    continue
                aergo_config_src += "\"" + k2 + "\", "
            aergo_config_src += "],\n"
        aergo_config_src += "}\n"

        aergo_config_src += """
AERGO_DEFAULT_CONF = {
"""
        for k, v in conf_type.items():
            ws = " " * 4
            category_name = v['key']

            if k != "BaseConfig":
                aergo_config_src += "    \"" + category_name + "\": {\n"
                ws *= 2

            child_conf = v.copy()
            for k2, v2 in child_conf.items():
                if 'key' == k2:
                    continue

                # nothing if the default value does not exist
                no_default_value = False
                for item in no_default_keys:
                    if item["category"] == k and item["key"] == k2:
                        no_default_value = True
                        break
                if no_default_value:
                    continue

                try:
                    if "BaseConfig" == k:
                        default_value = default_conf[k2]
                    else:
                        default_value = default_conf[category_name][k2]

                    if v2 == "string":
                        default_value = '"' + default_value + '"'

                    aergo_config_src += ws + "\"" + k2 + "\": " + str(default_value) + ",\n"
                except KeyError:
                    # no default value == remove key
                    pass

            if k != "BaseConfig":
                aergo_config_src += "    },\n"
        aergo_config_src += "}\n\n"
        aergo_config_src += """
class AergoConfig:
    def __init__(self):
        self.__conf = dict(AERGO_DEFAULT_CONF)
"""
        for k, v in conf_type.items():
            category_name = v['key']
            if k == "BaseConfig":
                continue
            aergo_config_src += "        self.__conf['" + category_name + "'] = dict(AERGO_DEFAULT_CONF['" + category_name + "'])\n"
        aergo_config_src += """
    def add_conf(self, k, v, c="base"):
        exist = False
        for key in AERGO_CONF_KEYS[c]:
            if key == k:
                exist = True
                break

        if not exist:
            raise KeyError("cannot find a configuration key: " + k)

        if c == "base":
            self.__conf[k] = v
        else:
            self.__conf[c][k] = v

    @property
    def conf(self):
        return self.__conf

"""
        for k, v in conf_type.items():
            # BaseConfig isn't categorized
            if k != "BaseConfig":
                func_name_prefix = v['key'] + "_"
                conf_target_prefix = "self.__conf['" + v['key'] + "']"
                aergo_config_src += "    @property\n"
                aergo_config_src += "    def " + v['key'] + "(self):\n"
                aergo_config_src += "        return " + conf_target_prefix + "\n\n"
            else:
                func_name_prefix = ""
                conf_target_prefix = "self.__conf"

            for k2, v2 in v.items():
                if 'key' == k2:
                    continue

                func_name = func_name_prefix + k2
                conf_target = conf_target_prefix + "['" + k2 + "']"
                property_func = "    @property\n"
                property_func += "    def " + func_name + "(self):\n"
                setter_func = "    @" + func_name + ".setter\n"
                setter_func += "    def " + func_name + "(self, v):\n"

                if "string" == v2:
                    property_func += "        return str(" + conf_target + ")\n\n"
                    setter_func += "        if not isinstance(v, str):\n"
                    setter_func += "            raise TypeError('input value should be a string type')\n"
                elif "bool" == v2:
                    property_func += "        return bool(" + conf_target + ")\n\n"
                    setter_func += "        if not isinstance(v, bool):\n"
                    setter_func += "            raise TypeError('input value should be a boolean type')\n"
                elif "int" in v2:
                    property_func += "        return int(" + conf_target + ")\n\n"
                    setter_func += "        if not isinstance(v, int):\n"
                    setter_func += "            raise TypeError('input value should be an integer type')\n"
                elif "[]string" == v2:
                    property_func += "        return " + conf_target + "\n\n"
                    setter_func += "        if not isinstance(v, list):\n"
                    setter_func += "            raise TypeError('input value should be an array type')\n"
                setter_func += "        " + conf_target + " = v\n\n"

                # generate property method
                aergo_config_src += property_func

                # generate setter method
                aergo_config_src += setter_func

        print(aergo_config_src)
    except Exception as e:
        traceback.print_exception(*sys.exc_info())
    finally:
        types_f.close()


if __name__ == '__main__':
    main()
